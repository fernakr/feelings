



window.s1 =  function ($_p)  {

  let player;
  let track;
  let opportunities = [];
  let currOpportunities = [];
  let bursts = [];
  let maxOpportunities = 10;

  let state = 'start';
  

  const bgColor = '#000';
  const lineColor = '#fff';  


  class Burst{
    constructor(x, y, size){
      this.x = x;
      this.y = y;
      this.size = size;      
      this.lifespan = 30;
      this.life = 0;
    }
    draw(){
      $_p.noStroke();
      // pink to rgba
      const pink = $_p.color('hotpink');
      $_p.fill($_p.lerpColor(pink, $_p.color('rgba(255,255,255,0)'), this.size/100));

      this.size = $_p.lerp(this.size, this.size * 2, this.life/this.lifespan)

      $_p.circle(this.x, this.y, this.size);
      this.life++;
      if (this.life > this.lifespan) bursts.splice(bursts.indexOf(this), 1);
    }
  }
  class Player{
    constructor(){
      this.y = $_p.height;
      this.speed = 2;
      this.score = 0;      
      this.vPoints = 0;  
      this.maxVPoints = 100;    
    }

    getSize = () => {

      const size = 20 + this.vPoints * 0.5
      //const maxSize = this.maxVPoints;
      return size > this.maxVPoints ? this.maxVPoints : size;
    }
    draw = () => {
      
      if (state === 'start'){        
        this.y -= this.speed;
        if (this.y < $_p.height/2){
          state = 'play';
        }
      }else{
        if (this.vPoints > 0) this.vPoints -= 0.1;
      }
      this.size = this.getSize();
      $_p.stroke(bgColor);
      
      $_p.fill($_p.lerpColor($_p.color('black'), $_p.color('hotpink'), this.vPoints/100));
      $_p.circle($_p.width/2, this.y, this.size);      
      
      $_p.textAlign($_p.LEFT, $_p.TOP);
      $_p.fill('hotpink');
      $_p.textSize(20);
      $_p.text(`Score: ${player.score.toFixed(2)}`, 10, 10);

    }
  }

  class Opportunity{
    constructor(y = 1){      
      const maxIntensity = 20;
      const minIntensity = 10;
      this.intensity = Math.random() * (maxIntensity - minIntensity) + minIntensity;
      this.size = ((maxIntensity - this.intensity) / maxIntensity) * 10 + 30;      
      this.y = y * $_p.height/10 - $_p.height;      
      const distance = $_p.abs($_p.height/2 - this.y);      
      const playerTime = distance / player.speed;
      
      this.speed = $_p.width/2 / playerTime;
      //console.log(this.speed);
      const chars = 'asdfhjkl';
      this.char = chars[Math.floor(Math.random() * chars.length)];

      // find if char is in first half of keyboard

      this.forward = chars.indexOf(this.char) < 4;
      this.x = (this.forward ? -1 : 1) * $_p.width/2 + $_p.width/2;     

      this.collided = false;
      this.attempt = null;
      this.past = false;
      // generate unique id
      this.id = Math.random().toString(36).substr(2, 9);
      if (!this.forward) this.speed *= -1; 
    }
    draw = () => {

      $_p.noStroke();
      //$_p.fill(lineColor);
      // opacity based on intensity

      let color = `rgba(0,0,0,${this.intensity/30})`;
      if (this.collided){
        color = `rgba(255,255,0,${this.intensity/30})`;
        if (this.attempt === 'success'){
          color = 'green';
        }else if (this.attempt === 'fail'){
          color = 'red';
        }else if (this.past){
          color = `rgba(255,255,255,${this.intensity/30})`;
        }

      }
      $_p.fill(color);
      $_p.circle(this.x, this.y, this.size);
      $_p.fill('hotpink');            
      $_p.textSize(this.size * 0.9);
      $_p.textAlign($_p.CENTER, $_p.CENTER);
      $_p.text(this.char.toUpperCase(), this.x, this.y);
      this.y += player.speed;
      this.x += this.speed;

      // check if player is touching opportunity
      if ($_p.dist(this.x, this.y, $_p.width/2, player.y) < (this.size/2 + player.size/2) && !this.collided){         
        this.collided = true;
        currOpportunities.push(this);
        opportunities.push(new Opportunity()); 
      }

      

      // check if opportunity is off screen      

      if (this.y > $_p.height + this.size/2){
        opportunities.splice(opportunities.indexOf(this), 1);
        if (!this.collided) opportunities.push(new Opportunity());        
      }

      if (this.y > $_p.height + this.size/2 || 
        ($_p.dist(this.x, this.y, $_p.width/2, player.y) > (this.size/2 + player.size/2) 
          && 
          (this.forward && this.x > $_p.width/2 
          || 
          !this.forward && this.x < $_p.width/2))){
        this.past = true;
        const collisionIndex = currOpportunities.findIndex(opportunity => this.id === opportunity.id);        
        if (collisionIndex !== -1)           
          currOpportunities.splice(collisionIndex, 1);        
        // splice out of array
        
      }

    }    
  }

  class Track{
    constructor(){
      this.offset = 0;      
      // load image 
      this.img = $_p.loadImage('./track.jpeg');

    }    
    draw = () => {
      // draw noise image
      //$_p.background(bgColor);
      // repeat image to fill screen
      $_p.imageMode($_p.CORNER);
      
      const imageHeight = $_p.height * 3;
      $_p.image(this.img, 0, $_p.height - imageHeight +  this.offset, $_p.width, imageHeight);
      if (this.offset > $_p.height) {        
        $_p.image(this.img, 0, $_p.height - 2 * imageHeight + this.offset, $_p.width, imageHeight);
        if (this.offset > $_p.height * 3) {
          this.offset = 0;
        }
      }
      if (state === 'play') this.offset += player.speed;

      

      // // draw dotted line
      
      // $_p.drawingContext.setLineDash([10, 15]);
      // $_p.drawingContext.lineDashOffset = this.offset;

      // $_p.stroke(lineColor);
      // $_p.strokeWeight(1);
      // $_p.line($_p.width/2, 0, $_p.width/2, $_p.height);

    }
  }


  $_p.setup = function () {
    $_p.createCanvas($_p.windowHeight, $_p.windowHeight);
    track = new Track();
    player = new Player();
    //$_p.background(bgColor);

    for (let i = 0; i < maxOpportunities; i++){
      opportunities.push(new Opportunity(i));
    }

  }

  $_p.draw = function () {
    $_p.background(bgColor);

    track.draw();
    player.draw();

    
    if (state === 'start'){

    }else if (state === 'play'){
      for (let i = 0; i < opportunities.length; i++){
        opportunities[i].draw();
      }
      for (let i = 0; i < bursts.length; i++){
        bursts[i].draw();
      }
    }
    
  }

  $_p.windowResized = function () {
    // resize canvas
    $_p.resizeCanvas($_p.windowHeight, $_p.windowHeight);
  }

  $_p.keyPressed = function () {
    // get key pressed
    const key = $_p.key.toLowerCase();
    // check if key is in currOpportunities
    
    let collision = false;
    currOpportunities.forEach((opportunity) => {
      
      if (opportunity.char === key){
        collision = true;
        if (player.vPoints < player.maxVPoints) player.vPoints += opportunity.intensity;
        player.score += opportunity.intensity;

        bursts.push(new Burst(opportunity.x, opportunity.y, opportunity.size));
        opportunities.splice(opportunities.indexOf(opportunity), 1);
      }else{
        opportunity.attempt = 'fail';
      } 
      currOpportunities.splice(currOpportunities.indexOf(opportunity), 1);
    });

    if (!collision){      
      if (player.vPoints > 0) {
        player.vPoints -= 5;

      }
    }
    

   

  }

}
if (window.p5instance) window.p5instance.remove();
window.p5instance = new p5(window.s1);