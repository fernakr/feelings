



window.s1 =  function ($_p)  {

  let player;
  let track;
  let opportunities = [];
  //let currOpportunities = [];
  let bursts = [];
  let opportunityDistance;
  let opportunityOffset = 0;
  let opportunityReverse = false;
  
  let opportunityActive;
  let phraseSubmitted = '';
  const dashOffset = [10, 15];

  let state = 'start';
  


  const bgColor = '#000';
  const lineColor = '#fff';  

  const writePhrase = () => {
    // write phrase on html overlay
    const phraseElem = document.getElementById('phrase');
    // remove leading spaces only
    phraseSubmitted = phraseSubmitted.replace(/^\s+/, '');
    
    if (opportunityActive && phraseSubmitted) {
        
      
      // parse every letter
      const phraseLetters = phraseSubmitted.split('');
      // wrap each letter in a span
      const phraseActive = opportunityActive.phrase.split('');
      const phraseLettersWrapped = phraseLetters.map((letter, i) => {    
        return `<span class="${ letter === phraseActive[i] ? 'is-correct' : ''}">${letter}</span>`
      });
      // toggle class is-correct if letter is correct mathing active phrase
      
      // phraseLettersWrapped.forEach((letter, i) => {
      //   if (letter === phraseActive[i]){
      //     phraseLettersWrapped[i] = `<span class="is-correct">${letter}</span>`;
      //   }
      // })

      // join letters
      phraseElem.innerHTML = phraseLettersWrapped.join('');
    }else{
      phraseElem.innerHTML = '';
    }

    //phraseElem.innerHTML = phraseSubmitted;    
    phraseElem.classList.toggle('is-active', phraseSubmitted.length > 0);
    
      
  }

  class Burst{
    
    constructor({ dots, attempt, dotSize, circlePos, intensity }){
      this.circlePos = circlePos;
      this.dots = dots;
      this.dotSize = dotSize;      
      this.lifespan = 30;
      this.life = 0;
      this.intensity = intensity;
      this.targetPosition = {         
        y: $_p.height,
        includePos: true
      }
      this.success = attempt === 'success';
      if (this.success){
        this.targetPosition = {
          x: player.x,
          y: player.y,
          includePos: false
        }
      }
      this.color = $_p.color(this.success ? 'limegreen' : 'red');

    }
    draw(){

      
      for (let i = 0; i < this.dots.length; i++){
        const dot = this.dots[i];
        
        $_p.fill(this.color.levels[0], this.color.levels[1], this.color.levels[2], dot.opacity * 255);        
        
        const dotPos = {
          x: this.targetPosition.x ? $_p.lerp(this.circlePos.x + dot.x, this.targetPosition.x, this.life/this.lifespan) : this.circlePos.x + dot.x,
          y: $_p.lerp(this.circlePos.y + dot.y, this.targetPosition.y + (this.targetPosition.includePos ? dot.y : 0) , this.life/this.lifespan)
        }
        $_p.circle(dotPos.x, dotPos.y, this.dotSize);
      }


      this.life++;
      if (this.life > this.lifespan) {
        bursts.splice(bursts.indexOf(this), 1);
        if (this.success){
          player.vPoints += this.intensity;
          player.score += this.intensity;
        }        
      }
    }
  }

  // class Phrase{
  //   constructor(){      
  //     this.x = $_p.width/2;
  //     this.y = $_p.height/2;      
  //   }
  //   draw(){
      
  //   }
  // }
  class Player{
    constructor(){
      this.y = $_p.height;
      this.speed = 4;
      this.score = 0;      
      this.vPoints = 0;  
      this.maxVPoints = 100;    
      this.x = $_p.width/2;
      this.theta = 0;      
      this.active = false;

    }

    getSize = () => {

      const size = 20 + this.vPoints * 0.5
      //const maxSize = this.maxVPoints;
      return size > this.maxVPoints ? this.maxVPoints : size;
    }
    draw = () => {
      
      if (state === 'start'){        
        this.y -= this.speed;
        if (this.y < $_p.height/2){
          state = 'play';
        }
      }else{
        
        if (this.vPoints > 0) this.vPoints -= 0.001;
        if (opportunityActive){
          const orbitCenter = {
            x: $_p.width/2 + (opportunityActive.reverse ? 1 : -1) * opportunityActive.radius,
            y: opportunityActive.y
          }

          //console.log(opportunityActive.thetaOffset);

          // calculate rotation speed from this.speed
          const rotationSpeed = opportunityActive.attempt === 'success' ? .1 : this.speed / opportunityActive.radius;            
          this.theta += rotationSpeed * opportunityActive.thetaDirection;
          this.x = orbitCenter.x + opportunityActive.radius * $_p.cos(this.theta + opportunityActive.thetaOffset);
          this.y = orbitCenter.y +  opportunityActive.radius * $_p.sin(this.theta + opportunityActive.thetaOffset);

          $_p.drawingContext.setLineDash(dashOffset);
          $_p.drawingContext.lineDashOffset = track.offset;
        
          $_p.circle(
            orbitCenter.x, 
            orbitCenter.y, 
            opportunityActive.radius * 2
          );

          // remove line dash
          $_p.drawingContext.setLineDash([]);
          $_p.stroke('white');
          $_p.noFill();     

          $_p.arc(
            orbitCenter.x, 
            orbitCenter.y, 
            opportunityActive.radius * 2, 
            opportunityActive.radius * 2, 
            opportunityActive.thetaOffset + (opportunityActive.thetaDirection < 0 ? this.theta : 0),  
            opportunityActive.thetaOffset + (opportunityActive.thetaDirection > 0 ? this.theta : 0)
          );

          if (opportunityActive.phrase === phraseSubmitted && opportunityActive.attempt !== 'success'){

            opportunityActive.attempt = 'success';            
          }
          if ($_p.abs(this.theta) >= $_p.TWO_PI - rotationSpeed) {    

            if (opportunityActive.phrase !== phraseSubmitted){
              opportunityActive.attempt = 'fail';              
            }

            opportunityActive.burst = true;
            bursts.push(new Burst(opportunityActive));

            this.y = $_p.height/2;
            opportunityActive = null;
            
            this.active = false;
            phraseSubmitted = '';
            writePhrase();       
          }

          
        }
      }
      this.size = this.getSize();
      $_p.noStroke();
      
      $_p.fill($_p.lerpColor($_p.color('black'), $_p.color('hotpink'), this.vPoints/100));
      $_p.circle(this.x, this.y, this.size);      
      
      $_p.textAlign($_p.LEFT, $_p.TOP);
      $_p.fill('hotpink');
      $_p.textSize(20);
      $_p.text(`Score: ${player.score.toFixed(2)}`, 10, 10);

    }
  }

  class Opportunity{
    constructor(index){      
      this.index = index;
      const maxIntensity = 20;
      const minIntensity = 10;
      this.intensity = Math.random() * (maxIntensity - minIntensity) + minIntensity;
      
      this.size = ((maxIntensity - this.intensity) / maxIntensity) * 10 + 30;      
      
      const distance = $_p.abs($_p.height/2 - this.y);      
      const playerTime = distance / player.speed;
      
      this.planetSize = $_p.map(this.intensity, minIntensity, maxIntensity, 100, 160);
      this.y = -this.planetSize; //    y * $_p.height/10 - $_p.height;      
      this.speed = $_p.width/2 / playerTime;      
      
      this.x = $_p.width/2;
      
      this.collided = false;
      this.attempt = null;
      this.burst = false;
      this.past = false;
      // generate unique id
      this.id = Math.random().toString(36).substr(2, 9);
      this.reverse = opportunityReverse
      opportunityReverse = !opportunityReverse;
      this.thetaDirection = this.reverse ? 1 : -1;
      this.thetaOffset = this.reverse ? $_p.PI : 0;
      

      // vulnerability statements
      const phrases = [
        'hello what is your name',
        'are you okay',
        'i am not okay',
        'do you want to talk',
        'i am here for you',
        'i am here to help',
        'i am here to listen'
        
      ]
      this.phrase = phrases[Math.floor(Math.random() * phrases.length)];

      this.dots = []


      for (let i = 0; i < this.intensity * 40; i++){
        // create a random dot in the circle area
        const theta = $_p.random($_p.TWO_PI);
        const dotPos = {
          x: this.planetSize/2 * $_p.random() * $_p.cos(theta),
          y: this.planetSize/2 * $_p.random() * $_p.sin(theta),
          opacity: $_p.random()
        }
        this.dots.push(dotPos);
      }
      this.dotSize = this.planetSize/this.intensity / 2
    }
    draw = () => {

      if (this.y > $_p.height + this.planetSize/2){
        this.dead = true;
      }
      $_p.noStroke();
      //$_p.fill(lineColor);
      // opacity based on intensity

      let color = $_p.color(0,0,0);
      if (this.collided){

        color = $_p.color(255,255,0);
        if (this.attempt === 'success'){
          color = $_p.color('limegreen');
        } else if (this.attempt === 'trying'){
          color =  $_p.color('orange')
        }else if (this.attempt === 'fail'){
          color =  $_p.color('red');
        }else if (this.past){
          color =  $_p.color(200,200,200);
        }        
      }

      //color = $_p.color(color, 3);
      //console.log((30 - this.intensity)/30 * 255);
      $_p.fill(color,(30 - this.intensity)/30 * 255);
      $_p.circle(this.x, this.y, 10);

      const offset = 100;
      
      this.radius = offset + this.planetSize/2;

      this.circlePos = {
        x: this.x + ( this.reverse  ? 1 : -1 ) * this.radius,
        y: this.y
      }      
      
      // draw dots

      //console.log(color);
      if (!this.burst){
        for (let i = 0; i < this.dots.length; i++){
          const dot = this.dots[i];
//           const { r, g, b } = $_p.color(color);
          $_p.fill(color.levels[0], color.levels[1], color.levels[2], dot.opacity * 255);        
          $_p.circle(this.circlePos.x + dot.x + 10 * $_p.cos( $_p.frameCount * .01 + dot.x * dot.y * 2), this.circlePos.y + dot.y + 10 * $_p.sin( $_p.frameCount * .01 + dot.x * dot.y * 2 + $_p.PI/3), this.dotSize);
        }
  
  
      }
      
      
      

      if (this.attempt === 'trying'){
        $_p.textAlign($_p.CENTER, $_p.CENTER);
        // make a rectangle the size of the phrase
        const phraseWidth = $_p.textWidth(this.phrase);
        const phraseHeight = $_p.textSize();
        $_p.noStroke();
        $_p.fill('rgba(0,0,0,.5)');
        $_p.rect(this.circlePos.x - phraseWidth/2, this.circlePos.y - phraseHeight/2, phraseWidth, phraseHeight);
        $_p.fill('hotpink');
        $_p.textSize(20);
        $_p.text(this.phrase, this.circlePos.x, this.circlePos.y);
  
      }
      
      if (!opportunityActive) this.y += player.speed;
      //this.x += this.speed;
      
      const grace = 4;
      // check if player is touching opportunity
      if ($_p.abs(this.y - player.y) < (this.size/2 + grace + player.size/2) && !this.collided && !player.active){         
        this.collided = true;
      }

      

      // check if opportunity is off screen      


      if (this.y > $_p.height/2 + this.size/2 + grace){
        this.past = true;
        
      }

    }    
  }

  class Track{
    constructor(){
      this.offset = 0;      
      // load image 
      //this.img = $_p.loadImage('./track.jpeg');

    }    
    draw = () => {
      // draw noise image
      //$_p.background(bgColor);
      // repeat image to fill screen
      // $_p.imageMode($_p.CORNER);
      
      // const imageHeight = $_p.height * 3;
      // $_p.image(this.img, 0, $_p.height - imageHeight +  this.offset, $_p.width, imageHeight);
      // if (this.offset > $_p.height) {        
      //   $_p.image(this.img, 0, $_p.height - 2 * imageHeight + this.offset, $_p.width, imageHeight);
      //   if (this.offset > $_p.height * 3) {
      //     this.offset = 0;
      //   }
      // }
      if (state === 'play' && !opportunityActive) this.offset -= player.speed;

      

      // // draw dotted line
      
      $_p.drawingContext.setLineDash(dashOffset);
      $_p.drawingContext.lineDashOffset = this.offset;

      $_p.stroke(lineColor);
      $_p.strokeWeight(1);

      const lineDivide = opportunityActive ? $_p.height/2 : player.y
      $_p.line($_p.width/2, 0, $_p.width/2, lineDivide);

      // reset line dash
      $_p.drawingContext.setLineDash([]);
      $_p.line($_p.width/2, lineDivide, $_p.width/2, $_p.height);  

    }
  }


  $_p.setup = function () {
    $_p.createCanvas($_p.windowHeight, $_p.windowHeight);
    track = new Track();
    player = new Player();
    opportunityDistance = $_p.height/3;
    //$_p.background(bgColor);

    //opportunities.push(new Opportunity(0));    

  }

  $_p.draw = function () {

    
    if (!opportunityActive && state === 'play') opportunityOffset += player.speed;

    if (opportunityOffset > opportunityDistance){
      opportunities.push(new Opportunity());
      opportunityOffset = 0;
    }

    $_p.background($_p.color(100));

    track.draw();
    player.draw();

    if (state === 'start'){

    }else if (state === 'play'){
      for (let i = 0; i < opportunities.length; i++){
        opportunities[i].draw();
      }
      opportunities = opportunities.filter(opportunity => !opportunity.dead);
      for (let i = 0; i < bursts.length; i++){
        bursts[i].draw();
      }
    }


    writePhrase();
    
    
  }

  $_p.windowResized = function () {
    // resize canvas
    $_p.resizeCanvas($_p.windowHeight, $_p.windowHeight);
  }

  $_p.keyPressed = function () {
    
    if (opportunityActive){

      // check if key is a letter or space or backspace
      if ($_p.keyCode >= 65 && $_p.keyCode <= 90 || $_p.keyCode === 32 || $_p.keyCode === 8){

    
        if ($_p.keyCode === 8){
          phraseSubmitted = phraseSubmitted.slice(0, -1);
        }else if ($_p.keyCode === 13){
          phraseSubmitted = '';
        }else{
          phraseSubmitted += $_p.key;
        }
      }
      
      // trim
      //phraseSubmitted = phraseSubmitted.trim();


      
      //console.log(phraseSubmitted);
    }else{
      // if key pressed is space
      if ($_p.keyCode === 32){
        const currOpportunity = opportunities.find(opportunity => opportunity.collided && !opportunity.past);

        if (currOpportunity){
          player.active = true;
          //player.y = currOpportunity.y;
          player.theta = 0;        
          currOpportunity.attempt = 'trying';      
          opportunityActive = currOpportunity;          
        };
        
        let collision = false;
        
        if (!collision){      
          if (player.vPoints > 0) {
            player.vPoints -= 5;

          }
        }
      }

    }
    
    
    

   

  }

}
if (window.p5instance) window.p5instance.remove();
window.p5instance = new p5(window.s1);