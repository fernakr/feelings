



window.s1 =  function ($_p)  {

  let player;
  let track;
  let opportunities = [];
  //let currOpportunities = [];
  let bursts = [];
  let opportunityDistance;
  let opportunityOffset = 0;
  let opportunityReverse = false;
  
  const maxLives = 3;
  let opportunityActive;
  let phraseSubmitted = '';
  const dashOffset = [10, 15];
  const playerLineStroke = 3;

  let state = 'start';
  
  const levels = [
    {
      name: 'Friendship',
      score: 100
    },
    {
      name: 'Companionship',
      score: 300
    }
  ]


  const bgColor = '#000';
  const lineColor = '#fff';  

  const writePhrase = () => {
    // write phrase on html overlay
    const phraseElem = document.getElementById('phrase');
    // remove leading spaces only
    phraseSubmitted = phraseSubmitted.replace(/^\s+/, '');
    
    if (opportunityActive && phraseSubmitted) {
        
      
      // parse every letter
      const phraseLetters = phraseSubmitted.split('');
      // wrap each letter in a span
      const phraseActive = opportunityActive.phrase.split('');
      player.lives = maxLives;
      const phraseLettersWrapped = phraseLetters.map((letter, i) => {    
        const correct = letter === phraseActive[i];
        if (!correct) player.lives -= 1;
        return `<span class="${ correct ? 'is-correct' : 'is-incorrect'}">${letter}</span>`
      });

      //console.log(player.lives);
      // toggle class is-correct if letter is correct mathing active phrase
      
      // phraseLettersWrapped.forEach((letter, i) => {
      //   if (letter === phraseActive[i]){
      //     phraseLettersWrapped[i] = `<span class="is-correct">${letter}</span>`;
      //   }
      // })

      // join letters
      phraseElem.innerHTML = phraseLettersWrapped.join('');
    }else{
      phraseElem.innerHTML = '';
    }

    //phraseElem.innerHTML = phraseSubmitted;    
    phraseElem.classList.toggle('is-active', phraseSubmitted.length > 0);
    
      
  }

  class Burst{
    
    constructor({ dots, attempt, dotSize, circlePos, intensity, fraction }){

      this.circlePos = circlePos;
      this.dots = dots;
      this.dotSize = dotSize;      
      this.lifespan = 30;
      this.life = 0;
      this.intensity = intensity;
      this.targetPosition = {         
        y: circlePos.y,
        x: circlePos.x,
      }
      this.fraction = fraction;
      if (this.fraction > 0){
        const numDots = $_p.ceil(this.dots.length * this.fraction);                  
        this.dots = this.dots.slice(0, numDots);  
      }else{
        this.dots = [];
      }
      this.success = attempt === 'success';
      if (this.success){
        this.targetPosition = {
          x: player.x,
          y: player.targetY,
          includePos: false
        }
      }
      this.color = $_p.color(this.success ? 'limegreen' : 'red');

    }
    draw(){

      
      
      for (let i = 0; i < this.dots.length; i++){
        const dot = this.dots[i];
        
        $_p.fill(this.color.levels[0], this.color.levels[1], this.color.levels[2], dot.opacity * 255);        
        
        const dotPos = {
          x: this.targetPosition.x ? $_p.lerp(this.circlePos.x + dot.x, this.targetPosition.x, this.life/this.lifespan) : this.circlePos.x + dot.x,
          y: $_p.lerp(this.circlePos.y + dot.y, this.targetPosition.y + (this.targetPosition.includePos ? dot.y : 0) , this.life/this.lifespan)
        }
        $_p.circle(dotPos.x, dotPos.y, this.dotSize);
      }


      this.life++;
      if (this.life > this.lifespan) {
        bursts.splice(bursts.indexOf(this), 1);
        if (this.success){
          player.vPoints += this.intensity;
          player.score += this.intensity;
        }        
      }
    }
  }

  class Goal{
    constructor(){
      this.x = $_p.width/2;
      this.y = $_p.height/10;
      this.level = levels[player.currLevel];      
    }
    draw(){
      $_p.noStroke();
    
      $_p.textAlign($_p.CENTER, $_p.CENTER);
      // make a rectangle the size of the phrase
      const padding = 20;
      const phraseWidth = $_p.textWidth(this.level.name) + padding;
      const phraseHeight = $_p.textSize() + padding;
      $_p.noStroke();
      $_p.fill('rgba(0,0,0,.5)');
      $_p.rect(this.x - phraseWidth/2, this.y - phraseHeight/2, phraseWidth, phraseHeight); 
      $_p.fill('white');
      $_p.text(`${this.level.name}`, this.x, this.y);
      
    }
  }



  // class Phrase{
  //   constructor(){      
  //     this.x = $_p.width/2;
  //     this.y = $_p.height/2;      
  //   }
  //   draw(){
      
  //   }
  // }
  class Player{
    constructor(){
      this.targetY = this.y = $_p.height;
      this.speed = 4;
      this.score = 0;      
      this.vPoints = 0;  
      this.maxVPoints = 100;    
      this.x = $_p.width/2;
      this.theta = 0;      
      this.active = false;
      this.currLevel = 0; 
      this.lives = maxLives;     
    }

    getSize = () => {

      const size = 20 + this.vPoints * 0.5
      //const maxSize = this.maxVPoints;
      return size > this.maxVPoints ? this.maxVPoints : size;
    }
    setPosition = () => {
      const prevLevelScore = this.currLevel > 0 ? levels[this.currLevel - 1].score : 0;
      const progress = (player.score - prevLevelScore)/(levels[player.currLevel].score - prevLevelScore);            
      this.targetY = $_p.height - ($_p.height/2 + ($_p.height/2 - $_p.height/10) * progress);

    }
    draw = () => {
      
      if (state === 'start'){        

        this.targetY -= this.speed;        
        if (this.y < $_p.height/2){
          state = 'play';
        }
      }else{
        
        if (this.vPoints > 0) this.vPoints -= 0.001;
        if (opportunityActive){
          const orbitCenter = {
            x: $_p.width/2 + (opportunityActive.reverse ? 1 : -1) * opportunityActive.radius,
            y: opportunityActive.y
          }

          //console.log(opportunityActive.thetaOffset);

          // calculate rotation speed from this.speed
          const rotationSpeed = opportunityActive.attempt === 'success' ? .1 : this.speed / opportunityActive.radius;            
          this.theta += rotationSpeed * opportunityActive.thetaDirection;
          this.x = orbitCenter.x + opportunityActive.radius * $_p.cos(this.theta + opportunityActive.thetaOffset);
          this.y = orbitCenter.y +  opportunityActive.radius * $_p.sin(this.theta + opportunityActive.thetaOffset);

          $_p.drawingContext.setLineDash(dashOffset);
          $_p.drawingContext.lineDashOffset = track.offset;
          $_p.strokeWeight(1);
          $_p.fill('rgba(0,0,0,.5)');
        
          $_p.circle(
            orbitCenter.x, 
            orbitCenter.y, 
            opportunityActive.radius * 2
          );

          // remove line dash
          $_p.drawingContext.setLineDash([]);
          $_p.strokeWeight(playerLineStroke);
          $_p.stroke('white');
          

          $_p.arc(
            orbitCenter.x, 
            orbitCenter.y, 
            opportunityActive.radius * 2, 
            opportunityActive.radius * 2, 
            opportunityActive.thetaOffset + (opportunityActive.thetaDirection < 0 ? this.theta : 0),  
            opportunityActive.thetaOffset + (opportunityActive.thetaDirection > 0 ? this.theta : 0)
          );

          if (opportunityActive.phrase === phraseSubmitted && opportunityActive.attempt !== 'success'){

            opportunityActive.attempt = 'success';            
          }
          if ($_p.abs(this.theta) >= $_p.TWO_PI - rotationSpeed) {    

            
            opportunityActive.attempt = opportunityActive.phrase.length === phraseSubmitted.length && player.lives >= 0 ? 'success' : 'fail';              
          
            //console.log(opportunityActive.attempt);

            opportunityActive.burst = true;
            bursts.push(new Burst(opportunityActive));

            this.setPosition();
            opportunityActive = null;
            
            this.active = false;
            phraseSubmitted = '';
            writePhrase();       
          }

          
        }
      }
      this.size = this.getSize();
      $_p.stroke('white');

      
      $_p.fill($_p.lerpColor($_p.color(57,20,104), $_p.color(162,242,239), this.vPoints/100));
      $_p.circle(this.x, this.y, this.size);      
      
      $_p.textAlign($_p.LEFT, $_p.TOP);
      $_p.noStroke();
      $_p.fill('white');
      $_p.textSize(20);
      
      $_p.text(`Score: ${player.score.toFixed(2)}`, 10, 10);
      if (this.y !== this.targetY) this.y = $_p.lerp(this.y, this.targetY, .1);
      if (this.score >= goal.level.score){        
        this.currLevel++;        
        goal.level = levels[this.currLevel];
        this.setPosition();
      }
      
    }   
  }

  class Opportunity{
    constructor(index){      
      this.index = index;
      const maxIntensity = 20;
      const minIntensity = 10;
      this.intensity = Math.random() * (maxIntensity - minIntensity) + minIntensity;
      
      this.size = ((maxIntensity - this.intensity) / maxIntensity) * 10 + 30;      
      
      const distance = $_p.abs($_p.height/2 - this.y);      
      const playerTime = distance / player.speed;
      
      this.planetSize = $_p.map(this.intensity, minIntensity, maxIntensity, 100, 160);
      this.y = -this.planetSize; //    y * $_p.height/10 - $_p.height;      
      this.speed = $_p.width/2 / playerTime;      
      
      this.x = $_p.width/2;
      
      this.collided = false;
      this.attempt = null;
      this.burst = false;
      this.past = false;
      // generate unique id
      this.id = Math.random().toString(36).substr(2, 9);
      this.reverse = opportunityReverse
      opportunityReverse = !opportunityReverse;
      this.thetaDirection = this.reverse ? 1 : -1;
      this.thetaOffset = this.reverse ? $_p.PI : 0;
      

      // vulnerability statements
      const phrases = [
        'hello what is your name',
        'are you okay',
        'i am not okay',
        'do you want to talk',
        'i am here for you',
        'i am here to help',
        'i am here to listen',
        'i really like you',        
        'i am sorry for hurting you',
        'i need to tell you something',
        'i need your help',


        
      ]
      this.phrase = phrases[Math.floor(Math.random() * phrases.length)];

      this.dots = []


      for (let i = 0; i < this.intensity * 40; i++){
        // create a random dot in the circle area
        const theta = $_p.random($_p.TWO_PI);
        const dotPos = {
          x: this.planetSize/2 * $_p.random() * $_p.cos(theta),
          y: this.planetSize/2 * $_p.random() * $_p.sin(theta),
          opacity: $_p.random()
        }
        this.dots.push(dotPos);
      }
      this.dotSize = this.planetSize/this.intensity / 2
    }
    draw = () => {

      if (this.y > $_p.height + this.planetSize/2){
        this.dead = true;
      }
      $_p.noStroke();
      //$_p.fill(lineColor);
      // opacity based on intensity

      let color = $_p.color(0,0,0);
      if (this.collided){

        color = $_p.color(255,255,0);
        if (this.attempt === 'success'){
          color = $_p.color('limegreen');
        } else if (this.attempt === 'trying'){
          color =  $_p.color('orange')
        }else if (this.attempt === 'fail'){
          color =  $_p.color('red');
        }else if (this.past){
          color =  $_p.color(200,200,200);
        }        
      }

      //color = $_p.color(color, 3);
      //console.log((30 - this.intensity)/30 * 255);
      $_p.fill(color,(30 - this.intensity)/30 * 255);
      $_p.circle(this.x, this.y, 10);

      const offset = 100;
      
      this.radius = offset + this.planetSize/2;

      this.circlePos = {
        x: this.x + ( this.reverse  ? 1 : -1 ) * this.radius,
        y: this.y
      }      
      
      let dots = this.dots;
      if (!this.burst){

        if (this.attempt !== null){
          this.fraction = player.lives > 0 ? player.lives / maxLives : 0;        
          if (this.fraction > 0){
            const numDots = $_p.ceil(this.dots.length * this.fraction);                  
            dots = dots.slice(0, numDots);  
          }else{
            dots = [];
          }

        
          
        }
        
        for (let i = 0; i < dots.length; i++){
          const dot = dots[i];
          $_p.fill(color.levels[0], color.levels[1], color.levels[2], dot.opacity * 255);        
          $_p.circle(this.circlePos.x + dot.x + 10 * $_p.cos( $_p.frameCount * .01 + dot.x * dot.y * 2), this.circlePos.y + dot.y + 10 * $_p.sin( $_p.frameCount * .01 + dot.x * dot.y * 2 + $_p.PI/3), this.dotSize);
        }
  
  
      }
      
      
      

      if (this.attempt === 'trying'){
        $_p.textAlign($_p.CENTER, $_p.CENTER);
        // make a rectangle the size of the phrase
        const padding = 8;
        const phraseWidth = $_p.textWidth(this.phrase) + padding;
        const phraseHeight = $_p.textSize() + padding;
        $_p.noStroke();
        $_p.fill('rgba(0,0,0,.5)');
        $_p.rect(this.circlePos.x - phraseWidth/2, this.circlePos.y - phraseHeight/2, phraseWidth, phraseHeight);
        $_p.fill('hotpink');
        $_p.textSize(20);
        $_p.text(this.phrase, this.circlePos.x, this.circlePos.y);
  
      }
      
      if (!opportunityActive) this.y += player.speed;
      //this.x += this.speed;
      
      const grace = 4;
      // check if player is touching opportunity
      if ($_p.abs(this.y - player.y) < (this.size/2 + grace + player.size/2) && !this.collided && !player.active){         
        this.collided = true;
      }

      

      // check if opportunity is off screen      


      if (this.y > player.y + this.size/2 + grace){
        this.past = true;
        
      }

    }    
  }

  class Track{
    constructor(){
      this.offset = 0;      
      // load image 
      //this.img = $_p.loadImage('./track.jpeg');

    }    
    draw = () => {
      // draw noise image
      //$_p.background(bgColor);
      // repeat image to fill screen
      // $_p.imageMode($_p.CORNER);
      
      // const imageHeight = $_p.height * 3;
      // $_p.image(this.img, 0, $_p.height - imageHeight +  this.offset, $_p.width, imageHeight);
      // if (this.offset > $_p.height) {        
      //   $_p.image(this.img, 0, $_p.height - 2 * imageHeight + this.offset, $_p.width, imageHeight);
      //   if (this.offset > $_p.height * 3) {
      //     this.offset = 0;
      //   }
      // }
      if (state === 'play' && !opportunityActive) this.offset -= player.speed;

      

      // // draw dotted line
      
      $_p.drawingContext.setLineDash(dashOffset);
      $_p.drawingContext.lineDashOffset = this.offset;

      $_p.stroke(lineColor);
      $_p.strokeWeight(1);

      const lineDivide = opportunityActive ? opportunityActive.y : player.y
      $_p.line($_p.width/2, 0, $_p.width/2, lineDivide);

      // reset line dash
      $_p.drawingContext.setLineDash([]);
      $_p.strokeWeight(playerLineStroke);
      $_p.line($_p.width/2, lineDivide, $_p.width/2, $_p.height);  

    }
  }


  $_p.setup = function () {
    $_p.createCanvas($_p.windowHeight, $_p.windowHeight);
    track = new Track();
    player = new Player();
    goal = new Goal();
    opportunityDistance = $_p.height/3;
    //$_p.background(bgColor);

    //opportunities.push(new Opportunity(0));    

  }

  $_p.draw = function () {

    
    if (!opportunityActive && state === 'play') opportunityOffset += player.speed;

    if (opportunityOffset > opportunityDistance){
      opportunities.push(new Opportunity());
      opportunityOffset = 0;
    }

    $_p.background($_p.color(56,79,69));

    track.draw();
    player.draw();
    goal.draw();

    if (state === 'start'){

    }else if (state === 'play'){
      for (let i = 0; i < opportunities.length; i++){
        opportunities[i].draw();
      }
      opportunities = opportunities.filter(opportunity => !opportunity.dead);
      for (let i = 0; i < bursts.length; i++){
        bursts[i].draw();
      }
    }

    
    writePhrase();
    
    
  }

  $_p.windowResized = function () {
    // resize canvas
    const width = $_p.windowWidth > $_p.windowHeight ? $_p.windowHeight : $_p.windowWidth;
    $_p.resizeCanvas(width, $_p.windowHeight);
    player.x = $_p.width/2;
    opportunities.forEach(opportunity => {
      opportunity.x = $_p.width/2;
    });
    goal.x = $_p.width/2;
  }

  $_p.keyPressed = function () {
    
    if (opportunityActive){

      // check if key is a letter or space or backspace
      if ($_p.keyCode >= 65 && $_p.keyCode <= 90 || $_p.keyCode === 32 || $_p.keyCode === 8){

    
        if ($_p.keyCode === 8){
          phraseSubmitted = phraseSubmitted.slice(0, -1);
        }else if ($_p.keyCode === 13){
          phraseSubmitted = '';
        }else{
          phraseSubmitted += $_p.key;
        }
      }
      
      // remove double spaces
      phraseSubmitted = phraseSubmitted.replace(/  +/g, ' ');


      
      //console.log(phraseSubmitted);
    }else{
      // if key pressed is space
      if ($_p.keyCode === 32){
        const currOpportunity = opportunities.find(opportunity => opportunity.collided && !opportunity.past && opportunity.attempt === null);

        if (currOpportunity){
          player.active = true;          
          player.theta = 0;       
          player.lives = maxLives; 
          currOpportunity.attempt = 'trying';      
          opportunityActive = currOpportunity;          
        };
        
        let collision = false;
        
        if (!collision){      
          if (player.vPoints > 0) {
            player.vPoints -= 5;

          }
        }
      }

    }
    
    
    

   

  }

}
if (window.p5instance) window.p5instance.remove();
window.p5instance = new p5(window.s1);