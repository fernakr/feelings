



window.s1 =  function ($_p)  {

  let player;
  let track;
  let opportunities = [];
  //let currOpportunities = [];
  let bursts = [];
  let opportunityDistance;
  let opportunityOffset = 0;
  let opportunityReverse = false;
  
  let opportunityActive;
  let phraseSubmitted = '';

  let state = 'start';
  


  const bgColor = '#000';
  const lineColor = '#fff';  

  const writePhrase = () => {
    // write phrase on html overlay
    const phraseElem = document.getElementById('phrase');
    if (opportunityActive) {
        
      
      // parse every letter
      const phraseLetters = phraseSubmitted.split('');
      // wrap each letter in a span
      const phraseActive = opportunityActive.phrase.split('');
      const phraseLettersWrapped = phraseLetters.map((letter, i) => {    
        return `<span class="${ letter === phraseActive[i] ? 'is-correct' : ''}">${letter}</span>`
      });
      // toggle class is-correct if letter is correct mathing active phrase
      
      // phraseLettersWrapped.forEach((letter, i) => {
      //   if (letter === phraseActive[i]){
      //     phraseLettersWrapped[i] = `<span class="is-correct">${letter}</span>`;
      //   }
      // })

      // join letters
      phraseElem.innerHTML = phraseLettersWrapped.join('');
    }else{
      phraseElem.innerHTML = '';
    }

    //phraseElem.innerHTML = phraseSubmitted;    
    phraseElem.classList.toggle('is-active', phraseSubmitted.length > 0);
    
      
  }

  class Burst{
    
    constructor({ dots, attempt, size, circlePos }){
      this.circlePos = circlePos;
      this.dots = dots;
      this.size = size;      
      this.lifespan = 30;
      this.life = 0;
      this.targetPosition = {         
        y: $_p.height
      }
      const success = attempt === 'success';
      if (success){
        this.targetPosition = {
          x: $_p.width/2,
          y: $_p.height/2
        }
      }
      this.color = success ? 'green' : 'red';

    }
    draw(){

      
      for (let i = 0; i < this.dots.length; i++){
        const dot = this.dots[i];
        
        $_p.fill($_p.color($_p.color(this.color), dot.opacity * 255));        
        
        const dotPos = {
          x: this.targetPosition.x ? $_p.lerp(this.circlePos.x + dot.x, this.targetPosition.x, this.life/this.lifespan) : this.circlePos.x + dot.x,
          y: $_p.lerp(this.circlePos.y + dot.y, this.targetPosition.y, this.life/this.lifespan)
        }
        $_p.circle(dotPos.x, dotPos.y, this.size);
      }


      this.life++;
      if (this.life > this.lifespan) bursts.splice(bursts.indexOf(this), 1);
    }
  }

  // class Phrase{
  //   constructor(){      
  //     this.x = $_p.width/2;
  //     this.y = $_p.height/2;      
  //   }
  //   draw(){
      
  //   }
  // }
  class Player{
    constructor(){
      this.y = $_p.height/2;
      this.speed = 5;
      this.score = 0;      
      this.vPoints = 0;  
      this.maxVPoints = 100;    
      this.x = $_p.width/2;
      this.theta = 0;      
      this.active = false;

    }

    getSize = () => {

      const size = 20 + this.vPoints * 0.5
      //const maxSize = this.maxVPoints;
      return size > this.maxVPoints ? this.maxVPoints : size;
    }
    draw = () => {
      
      if (state === 'start'){        
        this.y -= this.speed;
        if (this.y < $_p.height/2){
          state = 'play';
        }
      }else{
        
        if (this.vPoints > 0) this.vPoints -= 0.001;
        if (opportunityActive){
          const orbitCenter = {
            x: $_p.width/2 + (opportunityActive.reverse ? 1 : -1) * opportunityActive.radius,
            y: opportunityActive.y
          }

          //console.log(this.theta);

          // calculate rotation speed from this.speed
          const rotationSpeed = opportunityActive.attempt === 'success' ? .1 : this.speed / opportunityActive.radius;            
          this.theta += rotationSpeed * opportunityActive.thetaDirection;
          this.x = orbitCenter.x + opportunityActive.radius * $_p.cos(this.theta + opportunityActive.thetaOffset);
          this.y = orbitCenter.y +  opportunityActive.radius * $_p.sin(this.theta + opportunityActive.thetaOffset);
          $_p.stroke('white');
          $_p.noFill();     
          $_p.circle(orbitCenter.x, orbitCenter.y, opportunityActive.radius * 2);          

          if (opportunityActive.phrase === phraseSubmitted && opportunityActive.attempt !== 'success'){
            opportunityActive.attempt = 'success';            
          }
          if ($_p.abs(this.theta) > $_p.TWO_PI) {    

            if (opportunityActive.phrase !== phraseSubmitted){
              opportunityActive.attempt = 'fail';
            }else{
              this.vPoints += opportunityActive.intensity;
            }

            bursts.push(new Burst(opportunityActive));

            opportunityActive = null;
            
            this.active = false;
            phraseSubmitted = '';
            writePhrase();       
          }

          
        }
      }
      this.size = this.getSize();
      $_p.noStroke();
      
      $_p.fill($_p.lerpColor($_p.color('black'), $_p.color('hotpink'), this.vPoints/100));
      $_p.circle(this.x, this.y, this.size);      
      
      $_p.textAlign($_p.LEFT, $_p.TOP);
      $_p.fill('hotpink');
      $_p.textSize(20);
      $_p.text(`Score: ${player.score.toFixed(2)}`, 10, 10);

    }
  }

  class Opportunity{
    constructor(){      
      const maxIntensity = 20;
      const minIntensity = 10;
      this.intensity = Math.random() * (maxIntensity - minIntensity) + minIntensity;
      
      this.size = ((maxIntensity - this.intensity) / maxIntensity) * 10 + 30;      
      
      const distance = $_p.abs($_p.height/2 - this.y);      
      const playerTime = distance / player.speed;
      
      this.planetSize = $_p.map(this.intensity, minIntensity, maxIntensity, 100, 160);
      this.y = -this.planetSize; //    y * $_p.height/10 - $_p.height;      
      this.speed = $_p.width/2 / playerTime;      
      
      this.x = $_p.width/2;
      
      this.collided = false;
      this.attempt = null;
      this.past = false;
      // generate unique id
      this.id = Math.random().toString(36).substr(2, 9);
      this.reverse = opportunityReverse
      opportunityReverse = !opportunityReverse;
      this.thetaDirection = this.reverse ? 1 : -1;
      this.thetaOffset = this.reverse ? $_p.PI : 0;
      
      const phrases = [
        'hello what is your name',
        'are you okay',
        'i am not okay',
        'do you want to talk',
        'i am here for you',
      ]
      this.phrase = phrases[Math.floor(Math.random() * phrases.length)];

      this.dots = []


      for (let i = 0; i < this.intensity * 40; i++){
        // create a random dot in the circle area
        const theta = $_p.random($_p.TWO_PI);
        const dotPos = {
          x: this.planetSize/2 * $_p.random() * $_p.cos(theta),
          y: this.planetSize/2 * $_p.random() * $_p.sin(theta),
          opacity: $_p.random()
        }
        this.dots.push(dotPos);
      }
      this.dotSize = this.planetSize/this.intensity / 2
    }
    draw = () => {

      $_p.noStroke();
      //$_p.fill(lineColor);
      // opacity based on intensity

      let color = `rgba(0,0,0,${this.intensity/30})`;
      if (this.collided){
        color = `rgba(255,255,0,${this.intensity/30})`;
        if (this.attempt === 'success'){
          color = 'green';
        } else if (this.attempt === 'trying'){
          color = 'orange'
        }else if (this.attempt === 'fail'){
          color = 'red';
        }else if (this.past){
          color = `rgba(255,255,255,${this.intensity/30})`;
        }

      }
      $_p.fill(color);
      $_p.circle(this.x, this.y, this.size);

      const offset = 100;
      
      this.radius = player.size/2 +  offset + this.planetSize/2;

      this.circlePos = {
        x: this.x + ( this.reverse  ? 1 : -1 ) * this.radius,
        y: this.y
      }      
      
      // draw dots

      
      for (let i = 0; i < this.dots.length; i++){
        const dot = this.dots[i];
        $_p.fill($_p.color($_p.color(color), dot.opacity * 255));        
        $_p.circle(this.circlePos.x + dot.x + 1 * $_p.cos( track.offset * .01 + dot.x * dot.y * 2), this.circlePos.y + dot.y + 1 * $_p.sin( track.offset * .01 + dot.x * dot.y * 2), this.dotSize);
      }


      
      

      if (this.attempt === 'trying'){
        $_p.textAlign($_p.CENTER, $_p.CENTER);
        // make a rectangle the size of the phrase
        const phraseWidth = $_p.textWidth(this.phrase);
        const phraseHeight = $_p.textSize();
        $_p.noStroke();
        $_p.fill('rgba(0,0,0,.5)');
        $_p.rect(this.circlePos.x - phraseWidth/2, this.circlePos.y - phraseHeight/2, phraseWidth, phraseHeight);
        $_p.fill('hotpink');
        $_p.textSize(20);
        $_p.text(this.phrase, this.circlePos.x, this.circlePos.y);
  
      }
      
      if (!opportunityActive) this.y += player.speed;
      //this.x += this.speed;
      
      // check if player is touching opportunity
      if ($_p.abs(this.y - player.y) < (this.size/2 + player.size/2) && !this.collided && !player.active){         
        this.collided = true;
      }

      

      // check if opportunity is off screen      

      if (this.y > $_p.height + this.planetSize/2){
        opportunities.splice(opportunities.indexOf(this), 1);

      }

      if (this.y > $_p.height/2 + this.size/2){
        this.past = true;
        
      }

    }    
  }

  class Track{
    constructor(){
      this.offset = 0;      
      // load image 
      //this.img = $_p.loadImage('./track.jpeg');

    }    
    draw = () => {
      // draw noise image
      //$_p.background(bgColor);
      // repeat image to fill screen
      // $_p.imageMode($_p.CORNER);
      
      // const imageHeight = $_p.height * 3;
      // $_p.image(this.img, 0, $_p.height - imageHeight +  this.offset, $_p.width, imageHeight);
      // if (this.offset > $_p.height) {        
      //   $_p.image(this.img, 0, $_p.height - 2 * imageHeight + this.offset, $_p.width, imageHeight);
      //   if (this.offset > $_p.height * 3) {
      //     this.offset = 0;
      //   }
      // }
      if (state === 'play' && !  opportunityActive) this.offset -= player.speed;

      

      // // draw dotted line
      
      $_p.drawingContext.setLineDash([10, 15]);
      $_p.drawingContext.lineDashOffset = this.offset;

      $_p.stroke(lineColor);
      $_p.strokeWeight(1);
      $_p.line($_p.width/2, 0, $_p.width/2, $_p.height);

    }
  }


  $_p.setup = function () {
    $_p.createCanvas($_p.windowHeight, $_p.windowHeight);
    track = new Track();
    player = new Player();
    opportunityDistance = $_p.height/3;
    //$_p.background(bgColor);

    opportunities.push(new Opportunity());    

  }

  $_p.draw = function () {

    
    if (!opportunityActive) opportunityOffset += player.speed;

    if (opportunityOffset > opportunityDistance){
      opportunities.push(new Opportunity());
      opportunityOffset = 0;
    }

    $_p.background($_p.color(100));

    track.draw();
    player.draw();

    if (state === 'start'){

    }else if (state === 'play'){
      for (let i = 0; i < opportunities.length; i++){
        opportunities[i].draw();
      }
      for (let i = 0; i < bursts.length; i++){
        bursts[i].draw();
      }
    }


    if (phraseSubmitted) {    
      writePhrase();      
    }
    
    
  }

  $_p.windowResized = function () {
    // resize canvas
    $_p.resizeCanvas($_p.windowHeight, $_p.windowHeight);
  }

  $_p.keyPressed = function () {
    
    if (opportunityActive){

      if ($_p.keyCode === 8){
        phraseSubmitted = phraseSubmitted.slice(0, -1);
      }else if ($_p.keyCode === 13){
        phraseSubmitted = '';
      }else{
        phraseSubmitted += $_p.key;
      }
      // trim
      //phraseSubmitted = phraseSubmitted.trim();


      
      //console.log(phraseSubmitted);
    }else{
      // if key pressed is space
      if ($_p.keyCode === 32){
        const currOpportunity = opportunities.find(opportunity => opportunity.collided && !opportunity.past);

        if (currOpportunity){
          player.active = true;
          player.y = currOpportunity.y;
          player.theta = 0;        
          currOpportunity.attempt = 'trying';      
          opportunityActive = currOpportunity;          
        };
        
        let collision = false;
        
        if (!collision){      
          if (player.vPoints > 0) {
            player.vPoints -= 5;

          }
        }
      }

    }
    
    
    

   

  }

}
if (window.p5instance) window.p5instance.remove();
window.p5instance = new p5(window.s1);