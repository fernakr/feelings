



window.s1 =  function ($_p)  {

  let player;
  let track;
  let opportunities = [];
  //let currOpportunities = [];
  let bursts = [];
  let opportunityDistance;
  let opportunityOffset = 0;
  let opportunityReverse = false;

  let state = 'start';
  

  const bgColor = '#000';
  const lineColor = '#fff';  


  class Burst{
    constructor(x, y, size){
      this.x = x;
      this.y = y;
      this.size = size;      
      this.lifespan = 30;
      this.life = 0;
    }
    draw(){
      $_p.noStroke();
      // pink to rgba
      const pink = $_p.color('hotpink');
      $_p.fill($_p.lerpColor(pink, $_p.color('rgba(255,255,255,0)'), this.size/100));

      this.size = $_p.lerp(this.size, this.size * 2, this.life/this.lifespan)

      $_p.circle(this.x, this.y, this.size);
      this.life++;
      if (this.life > this.lifespan) bursts.splice(bursts.indexOf(this), 1);
    }
  }
  class Player{
    constructor(){
      this.y = $_p.height/2;
      this.speed = 2;
      this.score = 0;      
      this.vPoints = 0;  
      this.maxVPoints = 100;    
    }

    getSize = () => {

      const size = 20 + this.vPoints * 0.5
      //const maxSize = this.maxVPoints;
      return size > this.maxVPoints ? this.maxVPoints : size;
    }
    draw = () => {
      
      if (state === 'start'){        
        this.y -= this.speed;
        if (this.y < $_p.height/2){
          state = 'play';
        }
      }else{
        if (this.vPoints > 0) this.vPoints -= 0.1;
      }
      this.size = this.getSize();
      $_p.stroke(bgColor);
      
      $_p.fill($_p.lerpColor($_p.color('black'), $_p.color('hotpink'), this.vPoints/100));
      $_p.circle($_p.width/2, this.y, this.size);      
      
      $_p.textAlign($_p.LEFT, $_p.TOP);
      $_p.fill('hotpink');
      $_p.textSize(20);
      $_p.text(`Score: ${player.score.toFixed(2)}`, 10, 10);

    }
  }

  class Opportunity{
    constructor(){      
      const maxIntensity = 20;
      const minIntensity = 10;
      this.intensity = Math.random() * (maxIntensity - minIntensity) + minIntensity;
      
      this.size = ((maxIntensity - this.intensity) / maxIntensity) * 10 + 30;      
      this.y = 0; //y * $_p.height/10 - $_p.height;      
      const distance = $_p.abs($_p.height/2 - this.y);      
      const playerTime = distance / player.speed;
      this.planetSize = $_p.map(this.intensity, minIntensity, maxIntensity, 40, 80);
      // console.log(this.intensity);
      // console.log(this.planetSize)
      this.speed = $_p.width/2 / playerTime;
      //console.log(this.speed);
      // const chars = 'asdfhjkl';
      // this.char = chars[Math.floor(Math.random() * chars.length)];

      // find if char is in first half of keyboard

      //this.forward = chars.indexOf(this.char) < 4;
      this.x = $_p.width/2;
      //this.x = (this.forward ? -1 : 1) * $_p.width/2 + $_p.width/2;     

      this.collided = false;
      this.attempt = null;
      this.past = false;
      // generate unique id
      this.id = Math.random().toString(36).substr(2, 9);
      this.reverse = opportunityReverse
      opportunityReverse = !opportunityReverse;
      //if (!this.forward) this.speed *= -1; 
    }
    draw = () => {

      $_p.noStroke();
      //$_p.fill(lineColor);
      // opacity based on intensity

      let color = `rgba(0,0,0,${this.intensity/30})`;
      if (this.collided){
        color = `rgba(255,255,0,${this.intensity/30})`;
        if (this.attempt === 'success'){
          color = 'green';
        }else if (this.attempt === 'fail'){
          color = 'red';
        }else if (this.past){
          color = `rgba(255,255,255,${this.intensity/30})`;
        }

      }
      $_p.fill(color);
      $_p.circle(this.x, this.y, this.size);
      const offset = 40;
      
      $_p.circle(this.x + ( this.reverse  ? 1 : -1 ) * (player.size/2 +  offset + this.planetSize/2), this.y, this.planetSize);
      this.y += player.speed;
      //this.x += this.speed;

      // check if player is touching opportunity
      if ($_p.dist(this.x, this.y, $_p.width/2, player.y) < (this.size/2 + player.size/2) && !this.collided){         
        this.collided = true;
        //currOpportunities.push(this);
        //opportunities.push(new Opportunity()); 
      }

      

      // check if opportunity is off screen      

      if (this.y > $_p.height + this.size/2){
        opportunities.splice(opportunities.indexOf(this), 1);
        //if (!this.collided) opportunities.push(new Opportunity());        
      }

      if (this.y > $_p.height/2 + this.size/2){
        this.past = true;
        //const collisionIndex = currOpportunities.findIndex(opportunity => this.id === opportunity.id);        
        // if (collisionIndex !== -1)           
        //   currOpportunities.splice(collisionIndex, 1);        
        // splice out of array
        
      }

    }    
  }

  class Track{
    constructor(){
      this.offset = 0;      
      // load image 
      //this.img = $_p.loadImage('./track.jpeg');

    }    
    draw = () => {
      // draw noise image
      //$_p.background(bgColor);
      // repeat image to fill screen
      // $_p.imageMode($_p.CORNER);
      
      // const imageHeight = $_p.height * 3;
      // $_p.image(this.img, 0, $_p.height - imageHeight +  this.offset, $_p.width, imageHeight);
      // if (this.offset > $_p.height) {        
      //   $_p.image(this.img, 0, $_p.height - 2 * imageHeight + this.offset, $_p.width, imageHeight);
      //   if (this.offset > $_p.height * 3) {
      //     this.offset = 0;
      //   }
      // }
      if (state === 'play') this.offset -= player.speed;

      

      // // draw dotted line
      
      $_p.drawingContext.setLineDash([10, 15]);
      $_p.drawingContext.lineDashOffset = this.offset;

      $_p.stroke(lineColor);
      $_p.strokeWeight(1);
      $_p.line($_p.width/2, 0, $_p.width/2, $_p.height);

    }
  }


  $_p.setup = function () {
    $_p.createCanvas($_p.windowHeight, $_p.windowHeight);
    track = new Track();
    player = new Player();
    opportunityDistance = $_p.height/4;
    //$_p.background(bgColor);

    opportunities.push(new Opportunity());    

  }

  $_p.draw = function () {

    opportunityOffset += player.speed;

    if (opportunityOffset > opportunityDistance){
      opportunities.push(new Opportunity());
      opportunityOffset = 0;
    }

    $_p.background($_p.color(100));

    track.draw();
    player.draw();

    
    
    if (state === 'start'){

    }else if (state === 'play'){
      for (let i = 0; i < opportunities.length; i++){
        opportunities[i].draw();
      }
      for (let i = 0; i < bursts.length; i++){
        bursts[i].draw();
      }
    }
    
  }

  $_p.windowResized = function () {
    // resize canvas
    $_p.resizeCanvas($_p.windowHeight, $_p.windowHeight);
  }

  $_p.keyPressed = function () {
    

    const currOpportunity = opportunities.find(opportunity => opportunity.collided && !opportunity.past);

    if (currOpportunity){
      currOpportunity.attempt = 'success';
    };
    
    let collision = false;
    
    if (!collision){      
      if (player.vPoints > 0) {
        player.vPoints -= 5;

      }
    }
    

   

  }

}
if (window.p5instance) window.p5instance.remove();
window.p5instance = new p5(window.s1);